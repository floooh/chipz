//! an 'accumulator' for the instruction structure generated by decode.zig
const std = @import("std");
const assert = std.debug.assert;
const print = std.debug.print;
const Allocator = std.mem.Allocator;
const BoundedArray = std.BoundedArray;
const types = @import("types.zig");
const TCycle = types.TCycle;
const MCycle = types.MCycle;
const Op = types.Op;

var initialized = false;

var actions = BoundedArray(?[]const u8, 1024 * 1024){};
var tcycles = BoundedArray(TCycle, 256 * 1024){};
var mcycles = BoundedArray(MCycle, 64 * 1024){};
var main_ops = [_]Op{.{}} ** 256;
var ed_ops = [_]Op{.{}} ** 256;
var cb_ops = [_]Op{.{}} ** 256;
// TODO: Op block for 'special stuff'

// take a slice of actions and duplicate into heap-backed slice (not including the actual string payload!)
pub fn ac(s: []const ?[]const u8) []?[]const u8 {
    const start = actions.len;
    actions.appendSliceAssumeCapacity(s);
    return actions.slice()[start..actions.len];
}

// take a slice of TCycles, duplicate into heap-backed slice
pub fn tc(s: []const TCycle) []TCycle {
    const start = tcycles.len;
    tcycles.appendSliceAssumeCapacity(s);
    return tcycles.slice()[start..tcycles.len];
}

// take a slice of MCycles and duplicate into heap-backed slice
pub fn mc(s: []const MCycle) []MCycle {
    const start = mcycles.len;
    mcycles.appendSliceAssumeCapacity(s);
    return mcycles.slice()[start..mcycles.len];
}

pub fn mainOp(opcode: usize, op: Op) void {
    main_ops[opcode] = op;
}

pub fn dump() void {
    for (main_ops, 0..) |op, opcode| {
        if (op.mcycles.len > 0) {
            print("{X} => {s}:\n", .{ opcode, op.dasm });
            for (op.mcycles) |mcycle| {
                print("  type: {any}\n", .{mcycle.type});
                print("  tcycles:\n", .{});
                for (mcycle.tcycles, 0..) |tcycle, i| {
                    print("    {}: ", .{i});
                    for (tcycle.actions) |action_or_null| {
                        if (action_or_null) |action| {
                            print("{s}; ", .{action});
                        }
                    }
                    print("\n", .{});
                }
            }
        }
    }
}
