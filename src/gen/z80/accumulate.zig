//! an 'accumulator' for the instruction structure generated by decode.zig
const std = @import("std");
const assert = std.debug.assert;
const print = std.debug.print;
const Allocator = std.mem.Allocator;
const BoundedArray = std.BoundedArray;
const types = @import("types.zig");
const TCycle = types.TCycle;
const MCycle = types.MCycle;
const Op = types.Op;

var actions = BoundedArray(?[]const u8, 1024 * 1024){};
var tcycles = BoundedArray(TCycle, 256 * 1024){};
var mcycles = BoundedArray(MCycle, 64 * 1024){};
pub var main_ops = [_]Op{.{}} ** 256;
pub var ed_ops = [_]Op{.{}} ** 256;
pub var cb_ops = [_]Op{.{}} ** 256;

// take a slice of actions and duplicate into heap-backed slice (not including the actual string payload!)
pub fn ac(s: []const ?[]const u8) []?[]const u8 {
    const start = actions.len;
    actions.appendSliceAssumeCapacity(s);
    return actions.slice()[start..actions.len];
}

// take a slice of TCycles, duplicate into heap-backed slice
pub fn tc(s: []const TCycle) []TCycle {
    const start = tcycles.len;
    tcycles.appendSliceAssumeCapacity(s);
    return tcycles.slice()[start..tcycles.len];
}

// take a slice of MCycles and duplicate into heap-backed slice
pub fn mc(s: []const MCycle) []MCycle {
    const start = mcycles.len;
    mcycles.appendSliceAssumeCapacity(s);
    return mcycles.slice()[start..mcycles.len];
}

pub fn op(opcode: usize, o: Op) void {
    main_ops[opcode] = o;
}

pub fn edop(opcode: usize, o: Op) void {
    ed_ops[opcode] = o;
}
